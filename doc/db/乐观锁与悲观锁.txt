悲观锁：
1. 假定会发生并发冲突，悲观锁假定其他用户访问或者变更你正在访问或者变更的对象的概率很高，屏蔽一切可能违反数据完整性的操作
2. 悲观锁在你开始变化此对象之前就将该数据锁定，直到你提交所有的变更操作之后才会释放锁
3. 悲观锁的缺陷是，不论是页锁还是行锁，加锁时间可能很长，从而会长时间限制其他用户的访问，导致并发性能不好
4. 悲观锁一般依赖数据库的实现

乐观锁：
1. 假定不会发生并发冲突，只在提交数据时检查数据的完整性，乐观锁假定其他用户访问或者变更你正在访问或者变更的对象的概率很小，乐观锁不能解决脏读问题
2. 乐观锁在你提交数据之前才会将对象锁住，读取或者变更时，并不加锁
3. 乐观锁加锁时间较悲观锁短，它可以用较大的锁粒度获得较好的并发性能
4. 当B用户在A用户提交数据之前读取了A用户即将修改的数据，当A提交数据后，数据已经变更，B用户获取的数据并不是最新的数据，导致脏读问题，B用户不得不重新读取该数据，从而增加并发用户访问数据的次数