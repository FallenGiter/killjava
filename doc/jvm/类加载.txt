1. 生命周期
	1）加载：将类加载到内存
		1>通过全类名获取定义此类的二进制字节流
		2>将字节流的静态存储结构转化为方法区运行时数据结构
		3>在java堆中生成一个java.lang.Class对象，作为方法区数据访问的入口
	2）验证：保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害
		1>文件格式验证：验证字节流是否符合Class文件格式规范，并且能被当前JVM正确处理
		2>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范
		3>字节码验证：进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害JVM
		4>符号引用验证：符号引用验证发生在JVM将符号引用转化为直接引用的时候，这个转化在解析阶段发生
	3）准备：给变量分配内存并设置类变量（即静态变量，不包括实例变量）的初始值，对于非final的类变量，JVM会将其设置为“零值”
	4）解析：将常量池内的符号引用转化为直接引用，包括类	或接口的解析、字段的解析、方法的解析、接口方法的解析
	5）初始化：在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。
	6）使用：根据程序定义的行为执行
	7）卸载：由GC完成

2. 主要类加载器
	1）引导类加载器（bootstrap classloader）
		负责加载Java核心类
	2）扩展类加载器（extension classloader）
		负责加载JRE/lib/ext目录下的类
	3）系统加载类（system classloader）
		负责加载classpath或者java.class.path配置的目录和jar包
	
3. 加载原理
	全盘委托：当一个类加载器加载一个类时，该类所以来及引用的所有Class也有这个类加载器进行加载，除非限制指定另外一个类加载器加载
	1. 检查此Class是否已经加载过，如已加载则到8，否则到2
	2. 如果父类加载器不存在（即该加载器为bootstrap），则到4
	3. 请求父加载器加载该类，如果成功，则到8，否则到5
	4. 请求JVM用bootstrap加载器加载该类，如果成功到8
	5. 从类加载器的相关类路径寻找该类，如果找不到，则到7
	6. 从类文件载入该类，到8
	7. 抛出类找不到异常
	8. 返回该类